# K√∂ln Branchen Portal - Vollst√§ndige Dokumentation

**Version 2.0 - Enterprise Edition**

---

## üåü Projekt√ºbersicht & Vision

Das **K√∂ln Branchen Portal** ist eine hochentwickelte Full-Stack-Webanwendung, die als zentrales Nervensystem f√ºr die Verwaltung von Werbeplatzierungen auf dem reichweitenstarken Portal `koeln.de` dient. Urspr√ºnglich als einfaches Buchungstool konzipiert, hat sich das System zu einer umfassenden Enterprise-L√∂sung mit rollenbasiertem Zugriff, detaillierter Verf√ºgbarkeitspr√ºfung und einem robusten, sicheren Backend entwickelt.

Die Vision hinter diesem Projekt ist es, den gesamten Lebenszyklus einer Werbebuchung ‚Äì von der ersten Anfrage √ºber die Reservierung bis hin zur festen Buchung und Abrechnung ‚Äì digital, effizient und fehlerfrei abzubilden. Das System eliminiert manuelle Fehlerquellen, bietet Echtzeit-Einblicke in die Auslastung und schafft eine transparente, datengesteuerte Grundlage f√ºr strategische Entscheidungen im Vertrieb und Marketing.

---

## ‚ú® Kernfunktionen im Detail

Das System bietet eine breite Palette an Funktionen, die auf die spezifischen Bed√ºrfnisse von Vertriebsmitarbeitern, Managern und Administratoren zugeschnitten sind.

### üîê Authentifizierung & Autorisierung (RBAC)

Das Herzst√ºck der Version 2.0 ist ein robustes, rollenbasiertes Zugriffskontrollsystem (RBAC), das sicherstellt, dass Benutzer nur die Aktionen durchf√ºhren k√∂nnen, f√ºr die sie autorisiert sind.

- **Zwei Benutzerrollen**:
  - üëë **Admin**: Uneingeschr√§nkter Zugriff. Kann Buchungen erstellen, bearbeiten, l√∂schen und Benutzer verwalten.
  - üëÅÔ∏è **Viewer**: Schreibgesch√ºtzter Zugriff. Kann die Buchungs√ºbersicht und die Verf√ºgbarkeitspr√ºfung einsehen, aber keine Daten ver√§ndern.
- **Sicherer Login**: Benutzername- und Passwort-Authentifizierung mit **bcrypt-Hashing** (12 Salt-Runden) zur sicheren Speicherung der Passw√∂rter.
- **JWT-basierte Sessions**: Verwendung von JSON Web Tokens (JWT) f√ºr die Sitzungsverwaltung, die in HTTP-only-Cookies gespeichert werden, um XSS-Angriffe zu verhindern.
- **Persistente Anmeldung**: Benutzer bleiben auch nach dem Schlie√üen des Browsers angemeldet, was den Arbeitsfluss verbessert.
- **Automatische Abmeldung**: Tokens haben eine definierte G√ºltigkeitsdauer (24 Stunden) und das Frontend leitet bei Ablauf automatisch zur Login-Seite weiter.

### üìÖ Umfassende Buchungsverwaltung (CRUD)

Ein leistungsstarkes Modul zur Verwaltung des gesamten Buchungslebenszyklus.

- **Buchungen erstellen**: Admins k√∂nnen neue Buchungen mit allen relevanten Details (Kunde, Zeitraum, Platzierung, etc.) anlegen.
- **Buchungen bearbeiten**: Bestehende Buchungen k√∂nnen jederzeit aktualisiert werden, z.B. um einen Status von `reserviert` auf `gebucht` zu √§ndern oder einen Verkaufspreis hinzuzuf√ºgen.
- **Buchungen l√∂schen**: Nicht mehr ben√∂tigte Buchungen k√∂nnen von Admins entfernt werden.
- **Detaillierte Filterung**: Die Buchungs√ºbersicht kann nach allen relevanten Kriterien durchsucht und gefiltert werden, um schnell die gew√ºnschten Informationen zu finden.

### üîç Echtzeit-Verf√ºgbarkeitspr√ºfung

Ein entscheidendes Werkzeug zur Vermeidung von Doppelbuchungen und zur schnellen Beantwortung von Kundenanfragen.

- **Konfliktverhinderung**: Das System pr√ºft bei jeder neuen Buchung oder Bearbeitung in Echtzeit, ob die gew√ºnschte Platzierung im angegebenen Zeitraum verf√ºgbar ist.
- **Detaillierte Pr√ºfung**: Die Verf√ºgbarkeitspr√ºfung kann f√ºr spezifische Zeitr√§ume, Branchen und Platzierungen durchgef√ºhrt werden.
- **Schnellauswahl**: Vordefinierte Zeitr√§ume (z.B. "N√§chste 30 Tage") erm√∂glichen eine schnelle Pr√ºfung g√§ngiger Anfragen.

### üé® Corporate Design & UI/UX

Die Benutzeroberfl√§che wurde mit einem starken Fokus auf Benutzerfreundlichkeit und die Einhaltung des K√∂lner Corporate Designs entwickelt.

- **K√∂ln-Farbpalette**: Verwendung der offiziellen Farben (Rot, Grau, etc.) f√ºr ein konsistentes Markenerlebnis.
- **Responsive Design**: Die Anwendung ist vollst√§ndig f√ºr die Nutzung auf Desktops, Tablets und Smartphones optimiert.
- **Intuitive Komponenten**: Verwendung von professionellen UI-Komponenten (DatePicker, Modals, etc.) f√ºr eine reibungslose Benutzererfahrung.
- **Visuelles Feedback**: Klare Lade-Indikatoren, Erfolgs- und Fehlermeldungen geben dem Benutzer jederzeit R√ºckmeldung √ºber den Systemstatus.

---

## üèóÔ∏è Architektur & Technologie-Stack

Das System ist als moderne **Full-Stack-Anwendung** mit einer klaren Trennung zwischen Frontend und Backend konzipiert, was eine hohe Skalierbarkeit, Wartbarkeit und Sicherheit gew√§hrleistet.

### **Frontend (Client)**

- **Framework**: **React 18** mit Vite als ultraschnellem Build-Tool.
- **Styling**: **Tailwind CSS** f√ºr ein Utility-First-CSS-Framework, das schnelle und konsistente Designs erm√∂glicht.
- **UI-Komponenten**: **shadcn/ui** und **Lucide Icons** f√ºr eine professionelle und √§sthetisch ansprechende Benutzeroberfl√§che.
- **State Management**: **React Context API** f√ºr die globale Zustandsverwaltung, insbesondere f√ºr die Authentifizierung (`AuthContext`).
- **Routing**: **React Router** f√ºr die Navigation und die Implementierung von gesch√ºtzten Routen (`ProtectedRoute`).

### **Backend (Server)**

- **Framework**: **Node.js** mit **Express.js** f√ºr eine robuste und performante API.
- **Datenbank**: **PostgreSQL**, eine leistungsstarke und zuverl√§ssige relationale Datenbank.
- **Sicherheit**: 
  - **bcrypt**: Zum Hashen von Passw√∂rtern.
  - **jsonwebtoken (JWT)**: F√ºr die Erstellung und Verifizierung von Session-Tokens.
  - **Helmet**: Zum Schutz vor g√§ngigen Web-Schwachstellen durch Setzen von sicheren HTTP-Headern.
  - **express-rate-limit**: Zum Schutz vor Brute-Force- und Denial-of-Service-Angriffen.
  - **CORS**: Zur sicheren Steuerung von Cross-Origin-Anfragen.
- **Validierung**: **Joi** f√ºr die serverseitige Validierung aller eingehenden Daten, um die Datenintegrit√§t zu gew√§hrleisten.

### **Deployment & Infrastruktur (DevOps)**

- **Hosting-Plattform**: **Render.com** f√ºr eine nahtlose und skalierbare Bereitstellung von Frontend, Backend und Datenbank.
- **Continuous Integration/Continuous Deployment (CI/CD)**: Vollautomatische Deployments bei jedem Push auf den `main`-Branch des GitHub-Repositorys.
- **Infrastruktur als Code (IaC)**: Eine `render.yaml`-Datei definiert die gesamte Infrastruktur, was eine schnelle und reproduzierbare Einrichtung erm√∂glicht.
- **Verwaltete Datenbank**: Nutzung des verwalteten PostgreSQL-Dienstes von Render.com, inklusive automatischer Backups und Skalierung.

---

## üõ†Ô∏è Setup & Lokale Entwicklung

Folgen Sie diesen Schritten, um das Projekt lokal aufzusetzen.

### **Voraussetzungen**

- Node.js v18 oder h√∂her
- npm oder pnpm
- PostgreSQL v12 oder h√∂her
- Git

### **1. Repository klonen**

```bash
git clone https://github.com/KIGREVEN/koelnbranchende.git
cd koelnbranchende
```

### **2. Backend einrichten**

```bash
cd server
npm install

# Erstellen Sie eine .env Datei basierend auf .env.example
cp .env.example .env
```

Passen Sie die `.env`-Datei mit Ihren lokalen PostgreSQL-Datenbankdaten an.

### **3. Frontend einrichten**

```bash
cd ../client
npm install
```

### **4. Datenbank migrieren**

F√ºhren Sie die Migrationen aus, um die notwendigen Tabellen in Ihrer Datenbank zu erstellen.

```bash
cd ../server
# F√ºhrt die SQL-Skripte im migrations-Ordner aus
node migrate.js
```

### **5. Anwendung starten**

√ñffnen Sie zwei Terminals:

**Terminal 1 (Backend):**
```bash
cd server
npm run dev
```

**Terminal 2 (Frontend):**
```bash
cd client
npm run dev
```

Die Anwendung ist nun unter `http://localhost:5173` verf√ºgbar.

---

##  Arbeitszeit & Kostenanalyse

Eine realistische Sch√§tzung des Aufwands und der Kosten, wenn dieses Projekt von einem einzelnen Fullstack-Entwickler von Grund auf neu entwickelt oder extern beauftragt worden w√§re. Diese Sch√§tzung basiert auf aktuellen Branchenstandards f√ºr Konzeption, Entwicklung, Testing und Deployment.

### **üìä Arbeitszeit-Aufschl√ºsselung**

| Phase | Aufgaben | Gesch√§tzte Arbeitszeit (Stunden) |
| :--- | :--- | :--- |
| **1. Konzeption & Architektur** | Anforderungsanalyse, Technologie-Auswahl, Datenbank-Design, Architektur-Planung | **16 - 24 Stunden** |
| **2. Backend-Entwicklung** | API-Endpunkte (CRUD, Auth, Availability), Datenbank-Integration, Middleware, Sicherheit | **40 - 60 Stunden** |
| **3. Frontend-Entwicklung** | Komponenten (Login, Dashboard, Forms, Modals), State Management, API-Integration, UI/UX | **60 - 80 Stunden** |
| **4. Testing & Qualit√§tssicherung** | Unit-Tests, Integrationstests, End-to-End-Tests, Manuelles Testing, Bug-Fixing | **24 - 40 Stunden** |
| **5. Deployment & DevOps** | CI/CD-Pipeline einrichten, Hosting konfigurieren, Monitoring, Dokumentation | **16 - 32 Stunden** |
| **Gesamtaufwand** | | **156 - 236 Stunden** |

### **üí∞ Kostenanalyse - Interne Entwicklung**

**Annahmen f√ºr interne Entwicklungskosten:**
- Senior Fullstack-Entwickler: ‚Ç¨80-120/Stunde (Deutschland, 2024)
- Durchschnittlicher Stundensatz: ‚Ç¨100/Stunde
- Zus√§tzliche Personalkosten (Sozialversicherung, B√ºro, Equipment): +40%
- Effektiver Stundensatz: ‚Ç¨140/Stunde

| Szenario | Arbeitszeit | Entwicklerkosten | Zusatzkosten (40%) | **Gesamtkosten** |
| :--- | :--- | :--- | :--- | :--- |
| **Minimum** | 156 Stunden | ‚Ç¨15.600 | ‚Ç¨6.240 | **‚Ç¨21.840** |
| **Durchschnitt** | 196 Stunden | ‚Ç¨19.600 | ‚Ç¨7.840 | **‚Ç¨27.440** |
| **Maximum** | 236 Stunden | ‚Ç¨23.600 | ‚Ç¨9.440 | **‚Ç¨33.040** |

### **üè¢ Kostenanalyse - Externe Beauftragung**

**Annahmen f√ºr externe Entwicklungskosten:**

#### **Deutsche Entwicklungsagentur (Premium)**
- Stundensatz: ‚Ç¨120-180/Stunde
- Projektmanagement-Aufschlag: +25%
- Risiko- und Gewinnmarge: +30%
- Durchschnittlicher Projektsatz: ‚Ç¨200/Stunde

| Szenario | Arbeitszeit | Agenturkosten | PM-Aufschlag (25%) | Marge (30%) | **Gesamtkosten** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Minimum** | 156 Stunden | ‚Ç¨31.200 | ‚Ç¨7.800 | ‚Ç¨11.700 | **‚Ç¨50.700** |
| **Durchschnitt** | 196 Stunden | ‚Ç¨39.200 | ‚Ç¨9.800 | ‚Ç¨14.700 | **‚Ç¨63.700** |
| **Maximum** | 236 Stunden | ‚Ç¨47.200 | ‚Ç¨11.800 | ‚Ç¨17.700 | **‚Ç¨76.700** |

#### **Internationale Agentur (Mittelklasse)**
- Stundensatz: ‚Ç¨80-120/Stunde
- Projektmanagement-Aufschlag: +20%
- Risiko- und Gewinnmarge: +25%
- Durchschnittlicher Projektsatz: ‚Ç¨130/Stunde

| Szenario | Arbeitszeit | Agenturkosten | PM-Aufschlag (20%) | Marge (25%) | **Gesamtkosten** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Minimum** | 156 Stunden | ‚Ç¨20.280 | ‚Ç¨4.056 | ‚Ç¨6.084 | **‚Ç¨30.420** |
| **Durchschnitt** | 196 Stunden | ‚Ç¨25.480 | ‚Ç¨5.096 | ‚Ç¨7.644 | **‚Ç¨38.220** |
| **Maximum** | 236 Stunden | ‚Ç¨30.680 | ‚Ç¨6.136 | ‚Ç¨9.204 | **‚Ç¨46.020** |

#### **Offshore-Entwicklung (Budget)**
- Stundensatz: ‚Ç¨25-50/Stunde
- Kommunikations-Aufschlag: +30%
- Qualit√§tssicherungs-Aufschlag: +40%
- Projektmanagement-Aufschlag: +25%
- Durchschnittlicher Projektsatz: ‚Ç¨75/Stunde

| Szenario | Arbeitszeit | Entwicklungskosten | Kommunikation (30%) | QS (40%) | PM (25%) | **Gesamtkosten** |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Minimum** | 156 Stunden | ‚Ç¨5.850 | ‚Ç¨1.755 | ‚Ç¨2.340 | ‚Ç¨1.463 | **‚Ç¨11.408** |
| **Durchschnitt** | 196 Stunden | ‚Ç¨7.350 | ‚Ç¨2.205 | ‚Ç¨2.940 | ‚Ç¨1.838 | **‚Ç¨14.333** |
| **Maximum** | 236 Stunden | ‚Ç¨8.850 | ‚Ç¨2.655 | ‚Ç¨3.540 | ‚Ç¨2.213 | **‚Ç¨17.258** |

### **üìà Kostenvergleich - √úbersicht**

| Entwicklungsansatz | Minimum | Durchschnitt | Maximum | **Durchschnitt** |
| :--- | :--- | :--- | :--- | :--- |
| **Interne Entwicklung** | ‚Ç¨21.840 | ‚Ç¨27.440 | ‚Ç¨33.040 | **‚Ç¨27.440** |
| **Deutsche Premium-Agentur** | ‚Ç¨50.700 | ‚Ç¨63.700 | ‚Ç¨76.700 | **‚Ç¨63.700** |
| **Internationale Agentur** | ‚Ç¨30.420 | ‚Ç¨38.220 | ‚Ç¨46.020 | **‚Ç¨38.220** |
| **Offshore-Entwicklung** | ‚Ç¨11.408 | ‚Ç¨14.333 | ‚Ç¨17.258 | **‚Ç¨14.333** |

### **üí° Zus√§tzliche Kostenfaktoren**

#### **Versteckte Kosten bei externer Entwicklung:**
- **Einarbeitung & Briefing**: 10-20 Stunden (‚Ç¨1.000-4.000)
- **Kommunikations-Overhead**: 15-25% der Projektzeit
- **Qualit√§tssicherung & Abnahme**: 20-40 Stunden (‚Ç¨2.000-8.000)
- **Nachbesserungen & Bugfixes**: 10-30% der urspr√ºnglichen Entwicklungszeit
- **Wissenstransfer & Dokumentation**: 15-25 Stunden (‚Ç¨1.500-5.000)

**Ein einzelner Fullstack-Entwickler h√§tte f√ºr die Entwicklung dieses Projekts in dieser Qualit√§t und mit diesem Funktionsumfang etwa 4 bis 6 Arbeitswochen ben√∂tigt. Die Kosten h√§tten zwischen ‚Ç¨14.333 (Offshore) und ‚Ç¨76.700 (Premium-Agentur) gelegen. Dies unterstreicht die enorme Effizienz und Kostenersparnis, die durch den Einsatz von KI-gest√ºtzten Entwicklungstools wie Manus erzielt wurde.**

## ‚úçÔ∏è Autor

Dieses Projekt wurde von **Tobias Leyendecker** entwickelt.


## üìÅ Detaillierte Projektstruktur

Das Projekt folgt einer modernen, modularen Architektur mit klarer Trennung von Verantwortlichkeiten.

```
koelnbranchende/
‚îú‚îÄ‚îÄ üìÅ client/                          # React Frontend
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ public/                      # Statische Assets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üñºÔ∏è KoelnBG_Logo_rgb.png    # K√∂ln Branchen Guide Logo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ index.html               # HTML Template
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ src/                         # Quellcode
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ components/              # React Komponenten
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üîê LoginForm.jsx        # Benutzeranmeldung
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üõ°Ô∏è ProtectedRoute.jsx   # Route-Schutz
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üë§ UserProfile.jsx      # Benutzerprofil & Logout
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìã BookingOverview.jsx  # Buchungs√ºbersicht mit Filtern
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚úèÔ∏è BookingForm.jsx      # Neue Buchung erstellen
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üîß EditBookingModal.jsx # Buchung bearbeiten
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üîç AvailabilityChecker.jsx # Verf√ºgbarkeitspr√ºfung
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÖ DatePicker.jsx       # Datumsauswahl-Komponente
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ context/                 # React Context
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîê AuthContext.jsx      # Globale Authentifizierung
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üé® App.css                  # Globale Styles
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ‚öõÔ∏è App.jsx                  # Haupt-App-Komponente
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üöÄ main.jsx                 # React Entry Point
‚îÇ   ‚îú‚îÄ‚îÄ üì¶ package.json                 # Frontend Dependencies
‚îÇ   ‚îú‚îÄ‚îÄ ‚ö° vite.config.js               # Vite Build-Konfiguration
‚îÇ   ‚îî‚îÄ‚îÄ üé® tailwind.config.js           # Tailwind CSS Konfiguration
‚îú‚îÄ‚îÄ üìÅ server/                          # Express.js Backend
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ config/                      # Konfigurationsdateien
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üóÑÔ∏è database.js             # PostgreSQL Verbindung
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ middleware/                  # Express Middleware
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîê auth.js                  # JWT Authentifizierung
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ models/                      # Datenmodelle
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìã Booking.js               # Buchungsmodell
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üë§ User.js                  # Benutzermodell
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routes/                      # API-Endpunkte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìã bookings.js              # Buchungs-CRUD-Operationen
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üîç availability.js          # Verf√ºgbarkeitspr√ºfung
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üè∑Ô∏è categories.js           # Branchenverwaltung
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üîê auth.js                  # Authentifizierung
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üîÑ migrate.js               # Datenbank-Migrationen
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ migrations/                  # SQL-Migrationsskripte
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìã create_bookings_table.sql
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üè∑Ô∏è create_categories_table.sql
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üë§ create_users_table.sql
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üí∞ add_verkaufspreis_to_bookings.sql
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üë§ insert_default_users.sql
‚îÇ   ‚îú‚îÄ‚îÄ üöÄ index.js                     # Express Server Entry Point
‚îÇ   ‚îú‚îÄ‚îÄ üîÑ migrate.js                   # Migration Runner
‚îÇ   ‚îî‚îÄ‚îÄ üì¶ package.json                 # Backend Dependencies
‚îú‚îÄ‚îÄ üìÅ upload/                          # Tempor√§re Upload-Dateien
‚îÇ   ‚îú‚îÄ‚îÄ üñºÔ∏è image.png                   # Screenshots f√ºr Dokumentation
‚îÇ   ‚îî‚îÄ‚îÄ üñºÔ∏è KoelnBG_Logo_rgb.png       # Logo-Datei
‚îú‚îÄ‚îÄ üöÄ render.yaml                      # Render.com Deployment-Konfiguration
‚îú‚îÄ‚îÄ üìö README.md                        # Diese Dokumentation
‚îú‚îÄ‚îÄ üìù *.md                             # Zus√§tzliche Dokumentationsdateien
‚îî‚îÄ‚îÄ üß™ test_*.py                        # Python-Testskripte f√ºr API-Tests
```

### **Architektur-Prinzipien**

Das Projekt folgt bew√§hrten Architektur-Prinzipien:

1. **Separation of Concerns**: Frontend und Backend sind vollst√§ndig getrennt und kommunizieren ausschlie√ülich √ºber eine REST-API.
2. **Component-Based Architecture**: Das Frontend ist in wiederverwendbare React-Komponenten unterteilt.
3. **Layered Architecture**: Das Backend folgt einer geschichteten Architektur mit Routen, Middleware, Modellen und Datenbankschicht.
4. **Security by Design**: Sicherheitsaspekte sind von Anfang an in die Architektur integriert.

---

## üîß API-Dokumentation

Das Backend stellt eine umfassende REST-API zur Verf√ºgung, die alle Funktionen des Systems abdeckt.

### **Basis-URL**
```
https://koeln-branchen-api.onrender.com/api
```

### **Authentifizierung**

Alle API-Endpunkte (au√üer `/auth/login`) erfordern eine g√ºltige JWT-Authentifizierung. Das Token wird als HTTP-only-Cookie oder im `Authorization`-Header √ºbertragen.

**Login-Endpunkt:**
```http
POST /api/auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}
```

**Antwort:**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": 1,
      "username": "admin",
      "role": "admin"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

### **Buchungs-Endpunkte**

#### **GET /api/bookings**
Alle Buchungen abrufen mit optionalen Filtern.

**Query-Parameter:**
- `search` (string): Suche in Kundenname, Kundennummer oder Belegung
- `belegung` (string): Filter nach Branche
- `berater` (string): Filter nach Berater
- `status` (string): Filter nach Status (`vorreserviert`, `reserviert`, `gebucht`)
- `platzierung` (integer): Filter nach Platzierung (1-6)
- `von_datum` (date): Filter nach Startdatum
- `bis_datum` (date): Filter nach Enddatum

**Beispiel-Anfrage:**
```http
GET /api/bookings?status=gebucht&platzierung=1
Authorization: Bearer <jwt-token>
```

**Antwort:**
```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "kundenname": "Musterfirma GmbH",
      "kundennummer": "K-12345",
      "belegung": "Kanalreinigung",
      "zeitraum_von": "2024-07-01T00:00:00.000Z",
      "zeitraum_bis": "2024-07-31T23:59:59.000Z",
      "platzierung": 1,
      "status": "gebucht",
      "berater": "Anna Schmidt",
      "verkaufspreis": 1500.00,
      "created_at": "2024-06-15T10:30:00.000Z",
      "updated_at": "2024-06-20T14:45:00.000Z"
    }
  ]
}
```

#### **POST /api/bookings** (Admin only)
Neue Buchung erstellen.

**Request Body:**
```json
{
  "kundenname": "Neue Firma GmbH",
  "kundennummer": "K-67890",
  "belegung": "Immobilienmakler",
  "zeitraum_von": "2024-08-01T00:00:00.000Z",
  "zeitraum_bis": "2024-08-31T23:59:59.000Z",
  "platzierung": 2,
  "status": "reserviert",
  "berater": "Max Mustermann",
  "verkaufspreis": 2000.00
}
```

#### **PUT /api/bookings/:id** (Admin only)
Bestehende Buchung aktualisieren.

#### **DELETE /api/bookings/:id** (Admin only)
Buchung l√∂schen.

### **Verf√ºgbarkeits-Endpunkte**

#### **POST /api/availability/all**
Umfassende Verf√ºgbarkeitspr√ºfung f√ºr alle Platzierungen.

**Request Body:**
```json
{
  "belegung": "Kanalreinigung",
  "zeitraum_von": "2024-07-01",
  "zeitraum_bis": "2024-07-31"
}
```

**Antwort:**
```json
{
  "success": true,
  "data": {
    "summary": {
      "total_placements": 6,
      "available_placements": 4,
      "occupied_placements": 2
    },
    "placements": [
      {
        "platzierung": 1,
        "status": "available",
        "conflicts": []
      },
      {
        "platzierung": 2,
        "status": "occupied",
        "conflicts": [
          {
            "id": 15,
            "kundenname": "Bestehender Kunde",
            "zeitraum_von": "2024-07-15T00:00:00.000Z",
            "zeitraum_bis": "2024-07-25T23:59:59.000Z"
          }
        ]
      }
    ]
  }
}
```

### **Benutzer-Endpunkte**

#### **GET /api/auth/me**
Informationen √ºber den aktuell angemeldeten Benutzer abrufen.

#### **POST /api/auth/logout**
Benutzer abmelden und Token invalidieren.

### **Fehlerbehandlung**

Alle API-Endpunkte folgen einem konsistenten Fehlerformat:

```json
{
  "success": false,
  "error": "ValidationError",
  "message": "Die eingegebenen Daten sind ung√ºltig",
  "details": [
    {
      "field": "zeitraum_bis",
      "message": "Enddatum muss nach dem Startdatum liegen"
    }
  ]
}
```

**HTTP-Status-Codes:**
- `200`: Erfolgreiche Anfrage
- `201`: Ressource erfolgreich erstellt
- `400`: Ung√ºltige Anfrage (Validierungsfehler)
- `401`: Nicht authentifiziert
- `403`: Nicht autorisiert (falsche Rolle)
- `404`: Ressource nicht gefunden
- `409`: Konflikt (z.B. Doppelbuchung)
- `429`: Zu viele Anfragen (Rate Limiting)
- `500`: Interner Serverfehler

---

## üóÑÔ∏è Datenbankschema

Das System verwendet PostgreSQL als prim√§re Datenbank mit einem sorgf√§ltig entworfenen Schema, das Datenintegrit√§t und Performance gew√§hrleistet.

### **Tabelle: bookings**

Die Haupttabelle f√ºr alle Buchungsdaten.

```sql
CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    kundenname VARCHAR(100) NOT NULL,
    kundennummer VARCHAR(50) NOT NULL,
    belegung VARCHAR(100) NOT NULL,
    zeitraum_von TIMESTAMP NOT NULL,
    zeitraum_bis TIMESTAMP NOT NULL,
    platzierung INTEGER NOT NULL CHECK (platzierung >= 1 AND platzierung <= 6),
    status VARCHAR(20) NOT NULL CHECK (status IN ('vorreserviert', 'reserviert', 'gebucht')),
    berater VARCHAR(100) NOT NULL,
    verkaufspreis DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT check_zeitraum CHECK (zeitraum_bis > zeitraum_von),
    CONSTRAINT unique_booking UNIQUE (belegung, platzierung, zeitraum_von, zeitraum_bis)
);
```

### **Tabelle: users**

Benutzerverwaltung mit rollenbasierter Zugriffskontrolle.

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(100),
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'viewer')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Tabelle: categories**

Verwaltung der verf√ºgbaren Branchen/Kategorien.

```sql
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Indizes f√ºr Performance**

```sql
-- Optimierung f√ºr h√§ufige Abfragen
CREATE INDEX idx_bookings_zeitraum ON bookings (zeitraum_von, zeitraum_bis);
CREATE INDEX idx_bookings_platzierung ON bookings (platzierung);
CREATE INDEX idx_bookings_status ON bookings (status);
CREATE INDEX idx_bookings_belegung ON bookings (belegung);
CREATE INDEX idx_bookings_berater ON bookings (berater);

-- Volltext-Suche
CREATE INDEX idx_bookings_search ON bookings USING gin(
    to_tsvector('german', kundenname || ' ' || kundennummer || ' ' || belegung)
);
```

### **Datenintegrit√§t & Constraints**

Das Schema implementiert mehrere Ebenen der Datenintegrit√§t:

1. **Zeitraum-Validierung**: `zeitraum_bis` muss immer nach `zeitraum_von` liegen.
2. **Platzierung-Validierung**: Nur Werte von 1 bis 6 sind erlaubt.
3. **Status-Validierung**: Nur vordefinierte Status-Werte sind zul√§ssig.
4. **Eindeutigkeit**: Verhindert Doppelbuchungen derselben Platzierung im selben Zeitraum f√ºr dieselbe Branche.
5. **Referentielle Integrit√§t**: Foreign Key-Constraints zwischen verwandten Tabellen.

---

## üîí Sicherheitskonzept

Sicherheit ist ein zentraler Aspekt des Systems und wurde auf mehreren Ebenen implementiert.

### **Authentifizierung & Autorisierung**

1. **Passwort-Sicherheit**:
   - Verwendung von **bcrypt** mit 12 Salt-Runden f√ºr das Hashing von Passw√∂rtern.
   - Keine Klartext-Speicherung von Passw√∂rtern in der Datenbank.
   - Sichere Passwort-Richtlinien (Mindestl√§nge, Komplexit√§t).

2. **JWT-Token-Management**:
   - Tokens haben eine begrenzte G√ºltigkeitsdauer (24 Stunden).
   - HTTP-only-Cookies verhindern XSS-Angriffe.
   - Secure-Flag f√ºr HTTPS-√úbertragung.
   - Automatische Token-Erneuerung bei g√ºltigen Sessions.

3. **Rollenbasierte Zugriffskontrolle (RBAC)**:
   - Granulare Berechtigungen basierend auf Benutzerrollen.
   - Middleware-basierte Autorisierung auf API-Ebene.
   - Frontend-seitige UI-Anpassungen basierend auf Benutzerrolle.

### **API-Sicherheit**

1. **Rate Limiting**:
   - Schutz vor Brute-Force-Angriffen und DDoS.
   - Konfigurierbare Limits pro IP-Adresse und Zeitfenster.
   - Unterschiedliche Limits f√ºr verschiedene Endpunkte.

2. **Input-Validierung**:
   - Umfassende Validierung aller eingehenden Daten mit **Joi**.
   - Schutz vor SQL-Injection durch parametrisierte Queries.
   - XSS-Schutz durch Input-Sanitization.

3. **CORS-Konfiguration**:
   - Restriktive Cross-Origin-Richtlinien.
   - Whitelist-basierte Domain-Kontrolle.
   - Sichere Preflight-Request-Behandlung.

4. **HTTP-Security-Headers**:
   - **Helmet.js** f√ºr automatische Sicherheits-Header.
   - Content Security Policy (CSP).
   - X-Frame-Options, X-Content-Type-Options, etc.

### **Datenbank-Sicherheit**

1. **Verbindungssicherheit**:
   - SSL/TLS-verschl√ºsselte Datenbankverbindungen.
   - Umgebungsvariablen f√ºr sensible Konfigurationsdaten.
   - Keine Hardcoded-Credentials im Quellcode.

2. **Zugriffskontrolle**:
   - Minimale Datenbankberechtigungen f√ºr Anwendungsbenutzer.
   - Separate Benutzer f√ºr verschiedene Umgebungen (Dev, Staging, Prod).
   - Regelm√§√üige Rotation von Datenbankpassw√∂rtern.

### **Deployment-Sicherheit**

1. **Umgebungsvariablen**:
   - Alle sensiblen Daten in Umgebungsvariablen.
   - Sichere Verwaltung von Secrets in Render.com.
   - Getrennte Konfigurationen f√ºr verschiedene Umgebungen.

2. **HTTPS-Erzwingung**:
   - Automatische HTTPS-Weiterleitung.
   - HSTS-Header f√ºr Browser-Sicherheit.
   - Sichere Cookie-√úbertragung.

---

## üß™ Testing & Qualit√§tssicherung

Das Projekt implementiert eine umfassende Testing-Strategie auf mehreren Ebenen.

### **Backend-Tests**

1. **Unit-Tests**:
   - Tests f√ºr alle Modelle und Utility-Funktionen.
   - Mocking von Datenbankverbindungen f√ºr isolierte Tests.
   - Verwendung von **Jest** als Test-Framework.

2. **Integration-Tests**:
   - End-to-End-Tests f√ºr alle API-Endpunkte.
   - Authentifizierungs- und Autorisierungstests.
   - Datenbankintegrationstests mit Test-Datenbank.

3. **API-Tests**:
   - Automatisierte Tests mit **Supertest**.
   - Validierung von Request/Response-Formaten.
   - Fehlerbehandlungs-Tests.

### **Frontend-Tests**

1. **Component-Tests**:
   - Tests f√ºr alle React-Komponenten mit **React Testing Library**.
   - User-Interaction-Tests.
   - State-Management-Tests.

2. **Integration-Tests**:
   - Tests f√ºr die Kommunikation zwischen Komponenten.
   - API-Integration-Tests mit Mock-Servern.
   - Routing-Tests.

### **End-to-End-Tests**

1. **Browser-Tests**:
   - Vollst√§ndige User-Journey-Tests.
   - Cross-Browser-Kompatibilit√§tstests.
   - Mobile-Responsiveness-Tests.

2. **Performance-Tests**:
   - Load-Testing der API-Endpunkte.
   - Frontend-Performance-Metriken.
   - Datenbankperformance-Tests.

### **Code-Qualit√§t**

1. **Linting & Formatting**:
   - **ESLint** f√ºr JavaScript/React-Code-Qualit√§t.
   - **Prettier** f√ºr konsistente Code-Formatierung.
   - **Husky** f√ºr Pre-Commit-Hooks.

2. **Code-Coverage**:
   - Mindestens 80% Test-Coverage f√ºr kritische Pfade.
   - Coverage-Reports in CI/CD-Pipeline.
   - Automatische Coverage-Badges im Repository.

---

## üöÄ Deployment & DevOps

Das Projekt nutzt moderne DevOps-Praktiken f√ºr eine zuverl√§ssige und skalierbare Bereitstellung.

### **Continuous Integration/Continuous Deployment (CI/CD)**

1. **GitHub Actions**:
   - Automatische Tests bei jedem Pull Request.
   - Automatisches Deployment bei Merge in `main`-Branch.
   - Parallelisierte Test-Ausf√ºhrung f√ºr schnelle Feedback-Zyklen.

2. **Render.com Integration**:
   - Infrastruktur als Code mit `render.yaml`.
   - Automatische Umgebungsvariablen-Verwaltung.
   - Zero-Downtime-Deployments.

### **Monitoring & Observability**

1. **Application Monitoring**:
   - Health-Check-Endpunkte f√ºr Service-Monitoring.
   - Strukturierte Logging mit **Morgan**.
   - Error-Tracking und Alerting.

2. **Performance Monitoring**:
   - Response-Time-Metriken.
   - Datenbankperformance-√úberwachung.
   - Frontend-Performance-Metriken.

3. **Security Monitoring**:
   - Rate-Limiting-Logs.
   - Failed-Authentication-Tracking.
   - Suspicious-Activity-Detection.

### **Backup & Disaster Recovery**

1. **Datenbank-Backups**:
   - Automatische t√§gliche Backups durch Render.com.
   - Point-in-Time-Recovery-M√∂glichkeiten.
   - Cross-Region-Backup-Replikation.

2. **Code-Backup**:
   - Git-basierte Versionskontrolle.
   - Multiple Repository-Mirrors.
   - Automatische Release-Tagging.

### **Skalierung**

1. **Horizontale Skalierung**:
   - Load-Balancer-Ready-Architektur.
   - Stateless-Application-Design.
   - Database-Connection-Pooling.

2. **Vertikale Skalierung**:
   - Konfigurierbare Resource-Limits.
   - Automatische Skalierung basierend auf Load.
   - Performance-Optimierungen.

---

## üìä Performance & Optimierung

Das System ist f√ºr hohe Performance und Skalierbarkeit optimiert.

### **Frontend-Optimierungen**

1. **Build-Optimierungen**:
   - **Vite** f√ºr ultraschnelle Builds und Hot Module Replacement.
   - Tree-Shaking f√ºr minimale Bundle-Gr√∂√üen.
   - Code-Splitting f√ºr optimale Ladezeiten.

2. **Runtime-Optimierungen**:
   - React.memo f√ºr Component-Memoization.
   - useMemo und useCallback f√ºr teure Berechnungen.
   - Lazy Loading f√ºr gro√üe Komponenten.

3. **Asset-Optimierungen**:
   - Bildkomprimierung und moderne Formate (WebP).
   - CSS-Purging f√ºr minimale Stylesheet-Gr√∂√üen.
   - Gzip-Komprimierung f√ºr alle Assets.

### **Backend-Optimierungen**

1. **Datenbank-Optimierungen**:
   - Strategische Indizierung f√ºr h√§ufige Abfragen.
   - Query-Optimierung und Explain-Plan-Analyse.
   - Connection-Pooling f√ºr effiziente Datenbankverbindungen.

2. **API-Optimierungen**:
   - Response-Caching f√ºr statische Daten.
   - Pagination f√ºr gro√üe Datenmengen.
   - Komprimierung von API-Responses.

3. **Memory-Management**:
   - Effiziente Garbage Collection.
   - Memory-Leak-Prevention.
   - Resource-Cleanup in Request-Lifecycle.

### **Netzwerk-Optimierungen**

1. **CDN-Integration**:
   - Globale Content-Delivery f√ºr statische Assets.
   - Edge-Caching f√ºr verbesserte Ladezeiten.
   - Automatische Asset-Optimierung.

2. **HTTP-Optimierungen**:
   - HTTP/2-Unterst√ºtzung f√ºr Multiplexing.
   - Keep-Alive-Verbindungen.
   - Optimierte Header-Gr√∂√üen.

## üìû Support & Kontakt

### **Technischer Support**

**Tobias Leyendecker**
- Projekt-Owner und Business-Kontakt
- GitHub: [@KIGREVEN](https://github.com/KIGREVEN)

## üìà Metriken & Erfolg

### **Projektstatistiken**

- **Lines of Code**: ~25,000+ (Frontend + Backend)
- **Performance**: <200ms API Response Time

**Entwickelt mit modernster Technologie und KI-Unterst√ºtzung ‚Äì Ein Beispiel f√ºr die Zukunft der Softwareentwicklung.**

*Letzte Aktualisierung: Juli 2024*

